namespace MyLoadTest.IDoc
{
    using System;
    using System.Collections.Generic;
    using System.Collections.ObjectModel;
    using System.Linq;
    using System.Text;
    using System.Xml.Linq;
    using System.IO;
    using System.Xml;
    using System.Xml.XPath;
    using System.Xml.Schema;
    using System.Diagnostics;
    using System.Reflection;

    /// <summary>
    /// This class contains the definition of an IDoc (segments, fields, etc).
    /// The definition must be created from a file that has been exported from SAP.
    /// An Idoc is constructed of named segments (Dictionary?)
    /// A segment is constructed of fields that are position-based. Each field is a key, and each position has a start position and a length. 
    /// 
    /// Note: The IDocDefinition does not have a description, as these are not exported in the C Header or the IDoc Structure.
    /// 
    /// For those of you who have noticed that WE60 doesn't show the detailed documentation in the MySAP environments 
    /// and like me have been using the old 4.6c systems for reference, you can modify your personal settings to show 
    /// the documentation by default; here's the note: "As of Release 6.10, in transactions WE60 and WE63, 
    /// documentation is no longer generated by default for the segment fields when the documentation is generated. To
    /// activate the generation of the documentation from the corresponding data elements, proceed as follows: 
    /// WE60/WE63. > Goto > User settings. Here you must set the indicator for 'Display of the documentation' under 
    /// 'Display attributes for IDOC types' and then save the change. Now the documentation is also displayed for the 
    /// segment fields when WE60/WE63 is executed.
    /// Source: http://www.erpgenie.com/sapedi/idoc_interface.htm
    /// 
    /// Useful SAP transactions:
    /// WE60 is for Documentation for IDoc types 
    /// WE30 is for Creating IDoc extension type
    /// 
    /// </summary>
    public class IDocDefinition
    {
        #region private fields
        private DebugLog _log = DebugLog.Instance; // Note that field is not static, so cannot be called from static methods.
        private string _idocName;
        private Segment _controlRecord;
        private Segment _dataRecord;
        private Dictionary<string, Segment> _segments = new Dictionary<string, Segment>();
        #endregion

        #region public properties
        /// <summary>
        /// The IDoc name e.g. "ZISUPODMAS_BAPIZBUSMASSENDEM01".
        /// Note that this property can only be set when an instance of the class is created.
        /// </summary>
        public string Name
        {
            get { return _idocName; }
            private set
            {
                if (String.IsNullOrEmpty(value)) {
                    throw new IDocDefinitionException("IDoc name cannot be empty.");
                }
                _log.Write("IDoc name: {0}", value);
                _idocName = value;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        public Segment ControlRecord {
            get { return _controlRecord; }
            private set {
                _controlRecord = value;
            }
        }

        /// <summary>
        /// 
        /// </summary>
        public Segment DataRecord {
            get { return _dataRecord; }
            private set {
                _dataRecord = value;
            }
        }

        /// <summary>
        /// Note: probably shouldn't use this
        /// </summary>
        public Dictionary<string, Segment> Segments {
            get { return _segments; }
            private set {
                _segments = value;
            }
        }

        /// <summary>
        /// The IDoc description e.g. "BAPI Outbound;Meter Asset Standing Data Updates".
        /// Note that this property can only be set when an instance of the class is created.
        /// Note that this property can be found in the XSD definition, but not in the C-Header definition or the 
        /// Structure definition.
        /// </summary>
        //public string Description
        //{
        //    get { return _idocDescription; }
        //    private set
        //    {
        //        if (String.IsNullOrEmpty(value))
        //        {
        //            throw new IDocDefinitionException("IDoc description cannot be empty."); // This might cause problems if they haven't bothered to enter a description.
        //        }
        //        _log.Write("IDoc description: {0}", value);
        //        _idocDescription = value;
        //    }
        //}
        #endregion

        #region constructors
        /// <summary>
        /// Create an IDoc definition from an XSD that has been exported from SAP
        /// 
        /// Note: actually, you can't do this. The XSD should only be using for validating the IDoc that has been received/generated.
        /// Evidence of this statement: 
        ///   This Field definition, which does not specify a length.
        /// 
        /// <xsd:element name="TABNAM" type="xsd:string" fixed="EDI_DC40">
        ///   <xsd:annotation>
        ///    <xsd:documentation>Name of Table Structure</xsd:documentation>
        ///   </xsd:annotation>
        ///  </xsd:element>
        /// 
        /// Length is defined in C-Header as:
        ///       Char tabnam[10];                              // Name of Table Structure 
        /// 
        /// ...and in the Definition as:
        /// 
        ///       NAME                TABNAM
        ///       TEXT                Name of Table Structure
        ///       TYPE                CHARACTER
        ///       LENGTH              000010
        ///       FIELD_POS           0001
        ///       CHARACTER_FIRST     000001
        ///       CHARACTER_LAST      000010
        /// 
        /// </summary>
        /// <param name="xsd">IDoc definition XSD</param>
        private IDocDefinition(XElement xsd) {
            throw new NotImplementedException("It is not possible to create an IDocDefinition from the information in the XSD file.");
        }

        /// <summary>
        /// Constructor to create an IDocDefinition when the segment contents are already known
        /// Note: The c-Header and the exported Structure do not contain an IDoc description. The description is only 
        /// found in the XSD (which does not contain enough information to create an IDocDefinition).
        /// </summary>
        /// <param name="name">Name of IDoc type</param>
        /// <param name="controlRecord">The Control Record Segment</param>
        /// <param name="dataRecord">The Data Record Segment</param>
        /// <param name="segments">The Segments of the IDoc</param>
        public IDocDefinition(string name, Segment controlRecord, Segment dataRecord, Dictionary<string, Segment> segments) {
            _log.Write("========== New IDocDefinition created with Dictionary<> of Segments ==========");
            Name = name;
            ControlRecord = controlRecord;
            DataRecord = dataRecord;
            Segments = segments;
        }

        #endregion

        #region public methods
        /// <summary>
        /// Create an IDoc definition from an XSD file that has been exported from SAP.
        /// </summary>
        /// <param name="path">The XSD filename</param>
        /// <returns>Returns a new IDocDefinion object.</returns>
        public static IDocDefinition LoadXsd(string path)
        {
            // Read file contents
            XElement definition;
            try {
                definition = XElement.Load(path);
            } catch (Exception e) {
                string msg = String.Format("Problem reading file {0}", path);
                throw new IDocDefinitionException(msg, e);
            }
            return new IDocDefinition(definition);
        }

        /// <summary>
        /// Reads an IDoc Definition (C-Header) from the file system, and creates an IDocDefinition object.
        /// </summary>
        /// <param name="path">A file containing the IDoc Definition as a C Header.</param>
        /// <returns>A new IDocDefinition object</returns>
        public static IDocDefinition LoadHeader(string path) {
            DebugLog _log = DebugLog.Instance; // needed here as this is a static method.
            Segment controlRecord = null;
            Segment dataRecord = null;
            Dictionary<string, Segment> segments = new Dictionary<string, Segment>();

            _log.Write("Calling IDocDefinition.ParseHeader, with file: {0}", path);

            if (File.Exists(path) == false) {
                string msg = String.Format("Could not find C Header file: {0}", path);
                throw new IDocDefinitionException(msg);
            }

            _log.Write("C Header file contents:\n{0}", File.ReadAllText(path));

            // Convert the C code to XML (srcml) so it can be easily processed.
            XElement srcml = src2srcml(path);

            // The src2srcml command adds "src:" namespace prefixes to all elements.
            var nsm = new XmlNamespaceManager(new NameTable());
            nsm.AddNamespace("src", "http://www.sdml.info/srcML/src"); // Note that XPathSelectElement does not use the default namespace (""), will always return NULL if you query an XML document that has a default namespace.
            nsm.AddNamespace("cpp", "http://www.sdml.info/srcML/cpp");

            // Extract the field definitions from each IDoc segment (typedef/struct).
            IEnumerable<XElement> structsXml = srcml.XPathSelectElements("/src:typedef", nsm);
            foreach (XElement seg in structsXml) {
                String segmentName = seg.XPathSelectElement("./src:name", nsm).Value.ToUpper();
                String tmpSegDescComment = seg.XPathSelectElement("./src:type/src:struct/src:comment", nsm).Value;
                String segmentDescription = tmpSegDescComment.Substring(3, tmpSegDescComment.Length - (3+2)).TrimEnd(); // remove start/end block-comment, and any trailing whitespace.
                Segment currentSegment = new Segment(segmentName, segmentDescription); // must Add() each field to this separately.

                IEnumerable<XElement> fieldsXml = seg.XPathSelectElements("./src:type/src:struct/src:block/src:decl_stmt", nsm);
                IEnumerable<XElement> commentsXml = seg.XPathSelectElements("./src:type/src:struct/src:block/src:comment", nsm);
                if (fieldsXml.Count<XElement>() != commentsXml.Count<XElement>()) {
                    throw new IDocDefinitionException("Each field definition in the C-Header should have a matching comment.");
                }

                int fieldStartPos; // The starting position changes if it is a data segment.
                if (segmentDescription == "IDoc Control Record for Interface to External System") {
                    fieldStartPos = 0;
                    controlRecord = currentSegment;
                }
                else if (segmentDescription == "IDoc Data Record for Interface to External System") {
                    fieldStartPos = 0;
                    dataRecord = currentSegment;
                }
                else if (segmentDescription == "IDoc Status Record for Interface to External System") {
                    _log.Write("Skipping Status Record definition, as this is not needed to read an IDoc.");
                    continue;
                }
                else {
                    fieldStartPos = dataRecord["SDATA"].Position; // The Data Record will always be defined before any segments, so this should never get a NullPointerException.
                    segments.Add(segmentName, currentSegment);
                }

                List<Field> fields = new List<Field>();
                foreach (var fld in fieldsXml.Zip(commentsXml, (field, comment) => new { field, comment })) {
                    string fieldName = fld.field.XPathSelectElement("./src:decl/src:name/src:name", nsm).Value.ToUpper();
                    int fieldLength = Convert.ToInt32(fld.field.XPathSelectElement("./src:decl/src:name/src:index/src:expr", nsm).Value);
                    String tmpFldDescComment = fld.comment.Value;
                    String fieldDescription = tmpFldDescComment.Substring(3, tmpFldDescComment.Length - (3+2)).TrimEnd(); // remove start/end block-comment, and any trailing whitespace.
                    currentSegment.Add(new Field(fieldName, fieldDescription, fieldStartPos, fieldLength));
                    fieldStartPos += fieldLength;
                }
            }

            // To get the IDoc name, look for the comment that says "/* Segment structures for IDoc type ZISUPODMAS_BAPIZBUSMASSENDEM01 */".
            // Note that there is no IDoc description in the C-Header or the exported Structure.
            string tmpIdocName = srcml.XPathSelectElement("//src:comment[contains(., 'Segment structures for IDoc type')]", nsm).Value;
            String idocName = tmpIdocName.Substring(36, tmpIdocName.Length - (36+2)).TrimEnd(); // remove start/end block-comment, and any trailing whitespace.

            return new IDocDefinition(idocName, controlRecord, dataRecord, segments);
        }


        /// <summary>
        /// 
        /// The IDoc definition looks like this:
        /// BEGIN_RECORD_SECTION
        ///   BEGIN_CONTROL_RECORD
        ///     BEGIN_FIELDS
        ///       NAME                TABNAM
        ///       TEXT                Name of Table Structure
        ///       TYPE                CHARACTER
        ///       LENGTH              000010
        ///       FIELD_POS           0001
        ///       CHARACTER_FIRST     000001
        ///       CHARACTER_LAST      000010
        /// 
        /// The structure of the IDoc definition is:
        ///     BEGIN_RECORD_SECTION
        ///         BEGIN_CONTROL_RECORD
        ///             BEGIN_FIELDS (multiple fields)
        ///             END_FIELDS
        ///         END_CONTROL_RECORD
        ///         BEGIN_DATA_RECORD
        ///             BEGIN_FIELDS (multiple fields)
        ///             END_FIELDS
        ///         END_DATA_RECORD
        ///         BEGIN_STATUS_RECORD
        ///             BEGIN_FIELDS (multiple fields)
        ///             END_FIELDS
        ///         END_STATUS_RECORD
        ///     END_RECORD_SECTION
        ///     BEGIN_SEGMENT_SECTION
        ///         BEGIN_IDOC
        ///             BEGIN_SEGMENT (multiple segments)
        ///                 BEGIN_FIELDS (multiple fields)
        ///                 END_FIELDS
        ///             END_SEGMENT
        ///         END_IDOC
        ///     END_SEGMENT_SECTION  
        /// </summary>
        /// <param name="text">A String that contains TODO.</param>
        /// <returns></returns>
        //public static IDocDefinition ParseStructure(string text)
        //{
            //_log.Write("Parsing IDoc definition.");

            //// Note: will replace this with a state table in the future.
            //Dictionary<string, bool> state = new Dictionary<string, bool>() {
            //    {"RECORD_SECTION", false},
            //    {"CONTROL_RECORD", false},
            //    {"DATA_RECORD", false},
            //    {"STATUS_RECORD", false},
            //    {"SEGMENT_SECTION", false},
            //    {"IDOC", false},
            //    {"SEGMENT", false},
            //    {"FIELDS", false}
            //};

            //// break string into lines, and extract name and value using a regular expression.
            //using (StringReader sr = new StringReader(text))
            //{
            //    // Regular expression should match:
            //    // - the start of a line, then
            //    // - zero or more whitespace characters, then
            //    // - 1 or more alpha characters (the first word => name), then
            //    // - zero or more whitespace characters, then
            //    // - zero or more alpha characters or whitespace characters (multiple words => value), then
            //    // - the end of a line.
            //    // Note use of named groups
            //    // Useful C# regex tutorial here: http://www.codeproject.com/Articles/9099/The-30-Minute-Regex-Tutorial
            //    //Regex regex = new Regex(@"^\s*(?<name>\w+).*"); // works for first word
            //    //Regex regex = new Regex(@"^\s*\b(?<name>\w+)\b"); // works for first word
            //    Regex regex = new Regex(@"^\s*\b(?<name>\w+)\b\s*(?<value>[\w\s]*)$");
            //    Match match;
            //    string line;
            //    int lineNum = 0;
            //    while ((line = sr.ReadLine()) != null)
            //    {
            //        lineNum++;
            //        match = regex.Match(line);
            //        string name = match.Groups["name"].Value;
            //        string value = match.Groups["value"].Value;

            //        // TODO: Replace this with a proper state machine/state table. This is kludgy.
            //        switch (name)
            //        {
            //            case "":
            //                // Ignore blank lines
            //                break;
            //            case "BEGIN_RECORD_SECTION":
            //                if ((state["RECORD_SECTION"] == false) &&
            //                    (state["CONTROL_RECORD"] == false) &&
            //                    (state["DATA_RECORD"] == false) &&
            //                    (state["STATUS_RECORD"] == false) &&
            //                    (state["SEGMENT_SECTION"] == false) &&
            //                    (state["IDOC"] == false) &&
            //                    (state["SEGMENT"] == false) &&
            //                    (state["FIELDS"] == false))
            //                {
            //                    state["RECORD_SECTION"] = true;
            //                }
            //                else
            //                {
            //                    goto default;
            //                }
            //                break;
            //            case "END_RECORD_SECTION":
            //                if ((state["RECORD_SECTION"] == true) &&
            //                    (state["CONTROL_RECORD"] == false) &&
            //                    (state["DATA_RECORD"] == false) &&
            //                    (state["STATUS_RECORD"] == false) &&
            //                    (state["SEGMENT_SECTION"] == false) &&
            //                    (state["IDOC"] == false) &&
            //                    (state["SEGMENT"] == false) &&
            //                    (state["FIELDS"] == false))
            //                {
            //                    state["RECORD_SECTION"] = false;
            //                }
            //                else
            //                {
            //                    goto default;
            //                }
            //                break;
            //            case "BEGIN_CONTROL_RECORD":
            //                if ((state["RECORD_SECTION"] == true) &&
            //                    (state["CONTROL_RECORD"] == false) &&
            //                    (state["DATA_RECORD"] == false) &&
            //                    (state["STATUS_RECORD"] == false) &&
            //                    (state["SEGMENT_SECTION"] == false) &&
            //                    (state["IDOC"] == false) &&
            //                    (state["SEGMENT"] == false) &&
            //                    (state["FIELDS"] == false))
            //                {
            //                    state["CONTROL_RECORD"] = true;
            //                }
            //                else
            //                {
            //                    goto default;
            //                }
            //                break;
            //            case "END_CONTROL_RECORD":
            //                if ((state["RECORD_SECTION"] == true) &&
            //                    (state["CONTROL_RECORD"] == true) &&
            //                    (state["DATA_RECORD"] == false) &&
            //                    (state["STATUS_RECORD"] == false) &&
            //                    (state["SEGMENT_SECTION"] == false) &&
            //                    (state["IDOC"] == false) &&
            //                    (state["SEGMENT"] == false) &&
            //                    (state["FIELDS"] == false))
            //                {
            //                    state["CONTROL_RECORD"] = false;
            //                }
            //                else
            //                {
            //                    goto default;
            //                }
            //                break;
            //            case "TODO":
            //                if ((state["RECORD_SECTION"] == false) &&
            //                    (state["CONTROL_RECORD"] == false) &&
            //                    (state["DATA_RECORD"] == false) &&
            //                    (state["STATUS_RECORD"] == false) &&
            //                    (state["SEGMENT_SECTION"] == false) &&
            //                    (state["IDOC"] == false) &&
            //                    (state["SEGMENT"] == false) &&
            //                    (state["FIELDS"] == false))
            //                {
            //                    state["TODO"] = true;
            //                }
            //                else
            //                {
            //                    goto default;
            //                }
            //                break;
            //            case "TODO":
            //                if ((state["RECORD_SECTION"] == false) &&
            //                    (state["CONTROL_RECORD"] == false) &&
            //                    (state["DATA_RECORD"] == false) &&
            //                    (state["STATUS_RECORD"] == false) &&
            //                    (state["SEGMENT_SECTION"] == false) &&
            //                    (state["IDOC"] == false) &&
            //                    (state["SEGMENT"] == false) &&
            //                    (state["FIELDS"] == false))
            //                {
            //                    state["TODO"] = true;
            //                }
            //                else
            //                {
            //                    goto default;
            //                }
            //                break;
            //            case "TODO":
            //                if ((state["RECORD_SECTION"] == false) &&
            //                    (state["CONTROL_RECORD"] == false) &&
            //                    (state["DATA_RECORD"] == false) &&
            //                    (state["STATUS_RECORD"] == false) &&
            //                    (state["SEGMENT_SECTION"] == false) &&
            //                    (state["IDOC"] == false) &&
            //                    (state["SEGMENT"] == false) &&
            //                    (state["FIELDS"] == false))
            //                {
            //                    state["TODO"] = true;
            //                }
            //                else
            //                {
            //                    goto default;
            //                }
            //                break;
            //            case "TODO":
            //                if ((state["RECORD_SECTION"] == false) &&
            //                    (state["CONTROL_RECORD"] == false) &&
            //                    (state["DATA_RECORD"] == false) &&
            //                    (state["STATUS_RECORD"] == false) &&
            //                    (state["SEGMENT_SECTION"] == false) &&
            //                    (state["IDOC"] == false) &&
            //                    (state["SEGMENT"] == false) &&
            //                    (state["FIELDS"] == false))
            //                {
            //                    state["TODO"] = true;
            //                }
            //                else
            //                {
            //                    goto default;
            //                }
            //                break;
            //            case "TODO":
            //                if ((state["RECORD_SECTION"] == false) &&
            //                    (state["CONTROL_RECORD"] == false) &&
            //                    (state["DATA_RECORD"] == false) &&
            //                    (state["STATUS_RECORD"] == false) &&
            //                    (state["SEGMENT_SECTION"] == false) &&
            //                    (state["IDOC"] == false) &&
            //                    (state["SEGMENT"] == false) &&
            //                    (state["FIELDS"] == false))
            //                {
            //                    state["TODO"] = true;
            //                }
            //                else
            //                {
            //                    goto default;
            //                }
            //                break;
            //            case "TODO":
            //                if ((state["RECORD_SECTION"] == false) &&
            //                    (state["CONTROL_RECORD"] == false) &&
            //                    (state["DATA_RECORD"] == false) &&
            //                    (state["STATUS_RECORD"] == false) &&
            //                    (state["SEGMENT_SECTION"] == false) &&
            //                    (state["IDOC"] == false) &&
            //                    (state["SEGMENT"] == false) &&
            //                    (state["FIELDS"] == false))
            //                {
            //                    state["TODO"] = true;
            //                }
            //                else
            //                {
            //                    goto default;
            //                }
            //                break;
            //            case "TODO":
            //                if ((state["RECORD_SECTION"] == false) &&
            //                    (state["CONTROL_RECORD"] == false) &&
            //                    (state["DATA_RECORD"] == false) &&
            //                    (state["STATUS_RECORD"] == false) &&
            //                    (state["SEGMENT_SECTION"] == false) &&
            //                    (state["IDOC"] == false) &&
            //                    (state["SEGMENT"] == false) &&
            //                    (state["FIELDS"] == false))
            //                {
            //                    state["TODO"] = true;
            //                }
            //                else
            //                {
            //                    goto default;
            //                }
            //                break;
            //            case "TODO":
            //                if ((state["RECORD_SECTION"] == false) &&
            //                    (state["CONTROL_RECORD"] == false) &&
            //                    (state["DATA_RECORD"] == false) &&
            //                    (state["STATUS_RECORD"] == false) &&
            //                    (state["SEGMENT_SECTION"] == false) &&
            //                    (state["IDOC"] == false) &&
            //                    (state["SEGMENT"] == false) &&
            //                    (state["FIELDS"] == false))
            //                {
            //                    state["TODO"] = true;
            //                }
            //                else
            //                {
            //                    goto default;
            //                }
            //                break;
            //            case "TODO":
            //                if ((state["RECORD_SECTION"] == false) &&
            //                    (state["CONTROL_RECORD"] == false) &&
            //                    (state["DATA_RECORD"] == false) &&
            //                    (state["STATUS_RECORD"] == false) &&
            //                    (state["SEGMENT_SECTION"] == false) &&
            //                    (state["IDOC"] == false) &&
            //                    (state["SEGMENT"] == false) &&
            //                    (state["FIELDS"] == false))
            //                {
            //                    state["TODO"] = true;
            //                }
            //                else
            //                {
            //                    goto default;
            //                }
            //                break;
            //            case "TODO":
            //                if ((state["RECORD_SECTION"] == false) &&
            //                    (state["CONTROL_RECORD"] == false) &&
            //                    (state["DATA_RECORD"] == false) &&
            //                    (state["STATUS_RECORD"] == false) &&
            //                    (state["SEGMENT_SECTION"] == false) &&
            //                    (state["IDOC"] == false) &&
            //                    (state["SEGMENT"] == false) &&
            //                    (state["FIELDS"] == false))
            //                {
            //                    state["TODO"] = true;
            //                }
            //                else
            //                {
            //                    goto default;
            //                }
            //                break;
            //            case "TODO":
            //                if ((state["RECORD_SECTION"] == false) &&
            //                    (state["CONTROL_RECORD"] == false) &&
            //                    (state["DATA_RECORD"] == false) &&
            //                    (state["STATUS_RECORD"] == false) &&
            //                    (state["SEGMENT_SECTION"] == false) &&
            //                    (state["IDOC"] == false) &&
            //                    (state["SEGMENT"] == false) &&
            //                    (state["FIELDS"] == false))
            //                {
            //                    state["TODO"] = true;
            //                }
            //                else
            //                {
            //                    goto default;
            //                }
            //                break;
            //            case "TODO":
            //                if ((state["RECORD_SECTION"] == false) &&
            //                    (state["CONTROL_RECORD"] == false) &&
            //                    (state["DATA_RECORD"] == false) &&
            //                    (state["STATUS_RECORD"] == false) &&
            //                    (state["SEGMENT_SECTION"] == false) &&
            //                    (state["IDOC"] == false) &&
            //                    (state["SEGMENT"] == false) &&
            //                    (state["FIELDS"] == false))
            //                {
            //                    state["TODO"] = true;
            //                }
            //                else
            //                {
            //                    goto default;
            //                }
            //                break;
            //            case "TODO":
            //                if ((state["RECORD_SECTION"] == false) &&
            //                    (state["CONTROL_RECORD"] == false) &&
            //                    (state["DATA_RECORD"] == false) &&
            //                    (state["STATUS_RECORD"] == false) &&
            //                    (state["SEGMENT_SECTION"] == false) &&
            //                    (state["IDOC"] == false) &&
            //                    (state["SEGMENT"] == false) &&
            //                    (state["FIELDS"] == false))
            //                {
            //                    state["TODO"] = true;
            //                }
            //                else
            //                {
            //                    goto default;
            //                }
            //                break;
            //            case "NAME":
            //                if ((state["FIELDS"] == true) && (name == null))
            //                {
            //                    name = value;
            //                }
            //                else
            //                {
            //                    goto default;
            //                }
            //                break;
            //            case "TEXT":
            //                if ((state["FIELDS"] == true) && (text == null))
            //                {
            //                    text = value;
            //                }
            //                else
            //                {
            //                    goto default;
            //                }
            //            case "TYPE":
            //                if ((state["FIELDS"] == true) && (type == null))
            //                {
            //                    type = value;
            //                }
            //                else
            //                {
            //                    goto default;
            //                }
            //                break;
            //            case "LENGTH":
            //                if ((state["FIELDS"] == true) && (length == null))
            //                {
            //                    length = value;
            //                }
            //                else
            //                {
            //                    goto default;
            //                }
            //                break;
            //            case "FIELD_POS":
            //                if ((state["FIELDS"] == true) && (fieldPos == null))
            //                {
            //                    fieldPos = value;
            //                }
            //                else
            //                {
            //                    goto default;
            //                }
            //                break;
            //            case "CHARACTER_FIRST":
            //                if ((state["FIELDS"] == true) && (characterFirst == null))
            //                {
            //                    characterFirst = value;
            //                }
            //                else
            //                {
            //                    goto default;
            //                }
            //                break;
            //            case "CHARACTER_LAST":
            //                if (IsValidState(state) == true) { }
            //                if ((state["FIELDS"] == true) && (characterLast == null))
            //                {
            //                    characterLast = value;
            //                    // TODO: add field to segment.
            //                    // Reset all field values
            //                    name = null;
            //                    text = null;
            //                    type = null;
            //                    length = null;
            //                    fieldPos = null;
            //                    characterFirst = null;
            //                    characterLast = null;
            //                }
            //                else
            //                {
            //                    goto default;
            //                }
            //                break;
            //            default:
            //                string msg = String.Format("Invalid IDoc description element on line {0}.", lineNum);
            //                _log.Write(msg);
            //                throw new FormatException(msg);
            //                break;
            //        }

            //        Console.WriteLine("Name: {0}", match.Groups["name"].Value);
            //        Console.WriteLine("Value: {0}", match.Groups["value"].Value);
            //        //Console.WriteLine(match.Groups["value"].Value);
            //        // TODO: regex to break it into name/value pairs.

            //        // TODO

            //    }
            //}





            //Console.WriteLine();
            //return new IDocDefinition();
        //}

        /// The structure of the IDoc definition is:
        ///     BEGIN_RECORD_SECTION
        ///         BEGIN_CONTROL_RECORD
        ///             BEGIN_FIELDS (multiple fields)
        ///             END_FIELDS
        ///         END_CONTROL_RECORD
        ///         BEGIN_DATA_RECORD
        ///             BEGIN_FIELDS (multiple fields)
        ///             END_FIELDS
        ///         END_DATA_RECORD
        ///         BEGIN_STATUS_RECORD
        ///             BEGIN_FIELDS (multiple fields)
        ///             END_FIELDS
        ///         END_STATUS_RECORD
        ///     END_RECORD_SECTION
        ///     BEGIN_SEGMENT_SECTION
        ///         BEGIN_IDOC
        ///             BEGIN_SEGMENT (multiple segments)
        ///                 BEGIN_FIELDS (multiple fields)
        ///                 END_FIELDS
        ///             END_SEGMENT
        ///         END_IDOC
        ///     END_SEGMENT_SECTION  
        //private static bool IsValidState(byte[] state)
        //{
        //    // http://stackoverflow.com/questions/713341/comparing-arrays-in-c-sharp
        //    // var arraysAreEqual = Enumerable.SequenceEqual(a1, a2);
        //    // validStates.SequenceEqual()



        //    // A list of all valid states when reading an IDoc definition
        //    List<bool[]> validStates = new List<bool[]>();
        //    //                          RECORD_SECTION | CONTROL_RECORD | DATA_RECORD | STATUS_RECORD | SEGMENT_SECTION | IDOC | SEGMENT_SECTION | SEGMENT_VALUE | SEGMENT FIELDS | FIELD_VALUE
        //    validStates.Add(new bool[] { true, false, false, false, false, false, false, false, false, false }); // BEGIN_RECORD_SECTION. At start of IDoc definition.
        //    validStates.Add(new bool[] { false, false, false, false, false, false, false, false, false, false }); // BEGIN_CONTROL_RECORD.
        //    validStates.Add(new bool[] { false, false, false, false, false, false, false, false, false, false }); // .
        //    validStates.Add(new bool[] { false, false, false, false, false, false, false, false, false, false }); // END_RECORD_SECTION.
        //    validStates.Add(new bool[] { false, false, false, false, false, false, false, false, false, false }); // END_RECORD_SECTION.
        //    validStates.Add(new bool[] { false, false, false, false, false, false, false, false, false, false }); // END_RECORD_SECTION.
        //    validStates.Add(new bool[] { false, false, false, false, false, false, false, false, false, false }); // END_RECORD_SECTION.
        //    validStates.Add(new bool[] { false, false, false, false, false, false, false, false, false, false }); // BEGIN_FIELDS.
        //    validStates.Add(new bool[] { false, false, false, false, false, false, false, false, false, false }); // END_RECORD_SECTION.

        //    validStates.Add(new bool[] { false, false, false, false, false, false, false, false, false, false }); // END_RECORD_SECTION



        //    return false;
        //}
        #endregion

        #region private methods

        /// <summary>
        /// Converts C source code to srcml by calling src2srcml.exe
        /// 
        /// Command line: 
        /// src2srcml --language=C --xmlns:src=http://www.sdml.info/srcML/src idoc.xsd
        /// 
        /// Note that src2srcml.exe always reads from the filesystem to avoid the hanging problem that occurs when 
        /// piped input is longer than ~56 000 characters. The output is read from stdout (which has been redirected).
        /// It is not possible to suppress namespaces (using "--no-namespace-decl"), as this causes XElement.Load to 
        /// throw an exception (cpp namespace not found). Do not use "-o", as we want output to be sent to stdout.
        /// </summary>
        /// <param name="path">The file name of the C Header</param>
        /// <returns>An XElement containing a srcml represenation of the C Header</returns>
        private static XElement src2srcml(string path) {
            DebugLog _log = DebugLog.Instance; // needed here as this is a static method.

            // Call the src2srcml.exe process, and pass the source code to it via stdin.
            string dllFolder = Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location);
            int tabSize = 4;
            Process p = new Process() {
                StartInfo = {
                    FileName = dllFolder + @"\src2srcml\src2srcml.exe", // assume it is always installed in the \srcml subdirectory.
                    Arguments = String.Format("--language=C --xmlns:src=http://www.sdml.info/srcML/src \"{0}\"", path),
                    CreateNoWindow = true, // prevent the new shell window from briefly flashing up
                    UseShellExecute = false, // needs to be false in order to redirect output. Must specify the full path name, as it will not use the shell's %PATH% variable.
                    RedirectStandardOutput = true,
                    RedirectStandardError = true,
                    RedirectStandardInput = true, // redirect all 3, as it should be all 3 or none
                    WorkingDirectory = dllFolder // If p.WorkingDirectory is not specified, the default working directory is %SYSTEMROOT%\system32
                }
            };

            _log.Write("Calling \"{0}\" {1}", p.StartInfo.FileName, p.StartInfo.Arguments);
            p.Start();

            // Read output from stdout
            XElement srcml;
            try {
                string output = p.StandardOutput.ReadToEnd(); //.Dump()
                //Console.WriteLine("########## OUTPUT ##########\n{0}\n########## END OUTPUT ##########", output);

                srcml = XElement.Parse(output);

                // ...then wait n milliseconds for exit (as after exit, it can't read the output)
                p.WaitForExit(10000); // Documentation: http://msdn.microsoft.com/en-us/library/ty0d8k56.aspx
            } catch (Exception e) {
                var errorOutput = p.StandardError.ReadToEnd();
                string msg = String.Format("Error when calling src2srcml:\n{0}", errorOutput);
                throw new IDocDefinitionException(msg, e);
            } finally {
                p.Dispose(); // There is no real need to Close() if Dispose() is called.
            }

            return srcml;
        }

        #endregion
    }

    /// <summary>
    /// A segment is a collection of fields, with a segment name.
    /// 
    /// Note: fields must be added to the segment in the correct order.
    /// 
    /// Documentation for the KeyedCollection abstract base class: http://msdn.microsoft.com/en-us/library/ms132438.aspx
    /// Documentation for the Tuple class: http://msdn.microsoft.com/en-us/library/system.tuple.aspx
    /// </summary>
    public class Segment : KeyedCollection<string, Field>
    {
        #region fields
        private DebugLog _log = DebugLog.Instance;
        string _segmentName;
        string _segmentDescription;
        #endregion

        #region properties
        /// <summary>
        /// The Segment name e.g. "EDI_DC40".
        /// Note that this property can only be set when an instance of the class is created.
        /// </summary>
        public string Name {
            get { return _segmentName; }
            private set {
                if (String.IsNullOrEmpty(value)) {
                    throw new IDocDefinitionException("Segment name cannot be empty.");
                }
                _log.Write("Segment name: {0}", value);
                _segmentName = value;
            }
        }

        /// <summary>
        /// The Segment description type e.g. "IDoc Control Record for Interface to External System".
        /// Note that this property can only be set when an instance of the class is created.
        /// </summary>
        public string Description {
            get { return _segmentDescription; }
            private set {
                if (String.IsNullOrEmpty(value)) {
                    throw new IDocDefinitionException("Segment description cannot be empty."); // This might cause problems if they haven't bothered to enter a description.
                }
                _log.Write("Segment description: {0}", value);
                _segmentDescription = value;
            }
        }
        #endregion

        #region constructor

        /// <summary>
        /// If you use this constructor, you will have to call Add() for each field that is added to the IDoc.
        /// </summary>
        /// <param name="name">The Name of the Segment</param>
        /// <param name="description">The Description of the Segment</param>
        public Segment(string name, string description) {
            _log.Write("New Segment created without any Field objects. Fields must be added to the Segment by calling the Add() method.");
            Name = name;
            Description = description;
        }

        /// <summary>
        /// Create a new Segment from an List<> of fields.
        /// Using this constructor means that it is not necessary to call Add() for each Field.
        /// </summary>
        /// <param name="name">The Name of the Segment</param>
        /// <param name="description">The Description of the Segment</param>
        /// <param name="fields">A List<> of Fields</param>
        public Segment(string name, string description, List<Field> fields) {
            _log.Write("New Segment created from List<> of {0} Fields", fields.Count);
            Name = name;
            Description = description;
            foreach (Field field in fields) {
                this.Add(field);
            }
        }

        #endregion

        #region public methods
        /// <summary>
        /// Temporary method to print the fields in the input string (which is an IDoc segment/line from a text IDoc file.
        /// </summary>
        /// <param name="input"></param>
        public void PrintFields(string input)
        {
            foreach (Field field in this)
            {
                // TODO: http://stackoverflow.com/questions/644017/net-format-a-string-with-fixed-spaces
                Console.WriteLine("{0, 10}: {1}", field.Name, input.Substring(field.Position - 1, field.Length));
            }

        }
        #endregion

        #region private methods
        /// <summary>
        /// This is used by ...
        /// Note: When inheriting from KeyedCollection, this is the only method that absolutely must be overridden, 
        /// because without it the KeyedCollection cannot extract the keys from the items.
        /// </summary>
        /// <param name="field"></param>
        /// <returns>the fieldname as a string</returns>
        protected override string GetKeyForItem(Field field)
        {
            // The key is the field's name. 
            return field.Name;
        }
        #endregion
    }

    /// <summary>
    /// Field definition
    ///  - field name
    ///  - starting position
    ///  - length
    ///  - TODO: other field properties
    /// </summary>
    public class Field
    {
        #region private fields
        private DebugLog _log = DebugLog.Instance;
        String _fieldName;
        String _fieldDescription;
        int _startPos;
        int _length;
        // TODO: make these match the names in the definition.
        // add more field properties.
        // NOTE: do this after I can parse the input file.
        #endregion

        #region properties
        /// <summary>
        /// The field name
        /// </summary>
        public string Name
        {
            get { return _fieldName; }
            private set {
                if (String.IsNullOrEmpty(value)) {
                    throw new IDocDefinitionException("Field name cannot be empty.");
                }
                _log.Write("Field name: {0}", value);
                _fieldName = value;
            }
        }

        /// <summary>
        /// The field description
        /// </summary>
        public string Description {
            get { return _fieldDescription; }
            private set {
                if (String.IsNullOrEmpty(value)) {
                    throw new IDocDefinitionException("Field description cannot be empty.");
                }
                _log.Write("Field description: {0}", value);
                _fieldDescription = value;
            }
        }

        /// <summary>
        /// The starting position of the field i.e. the byte/character offset.
        /// Note tht fields never start at 0, as the segment name takes up the first x characters.
        /// </summary>
        public int Position
        {
            get { return _startPos; }
            private set {
                if (value < 0) {
                    string msg = String.Format("Field starting position cannot be negative. Value: {0}", value);
                    throw new IDocDefinitionException(msg);
                }
                _log.Write("Field starting position: {0}", value);
                _startPos = value;
            }
        }

        /// <summary>
        /// The length of the field in bytes/characters. Length is measured from the field's starting position.
        /// </summary>
        public int Length
        {
            get { return _length; }
            private set {
                if (value < 1) {
                    string msg = String.Format("Field length position cannot be 0 or negative. Value: {0}", value);
                    throw new IDocDefinitionException(msg);
                }
                _log.Write("Field length position: {0}", value);
                _length = value;
            }
        }
        #endregion

        #region constructors
        /// <summary>
        /// The no-args constructor is not allowed
        /// </summary>
        private Field() { }

        /// <summary>
        /// Field constructor.
        /// 
        /// When a Field object is created, the field definition must be specified.
        /// </summary>
        /// <param name="fieldName">The name of the Field</param>
        /// <param name="fieldDescription">The description of the Field</param>
        /// <param name="startPos">The starting position of the field. Note that this may have be to be calculated from the lengths of the preceeding fields.</param>
        /// <param name="length">The length of the Field</param>
        public Field(string fieldName, string fieldDescription, int startPos, int length) {
            Name = fieldName;
            Description = fieldDescription;
            Position = startPos;
            Length = length;
        }

        // TODO:
        /// <summary>
        /// Note that the length of the Field is calculated from the length of the enum values (which should all be the same length).
        /// Note: I don't really need this anymore, as it is not possible to create an IDoc definition from the XSD, only to verify an IDoc XML.
        /// </summary>
        /// <param name="fieldName">The name of the Field</param>
        /// <param name="fieldDescription">The description of the Field</param>
        /// <param name="startPos">The starting position of the field. Note that this may have be to be calculated from the lengths of the preceeding fields.</param>
        /// <param name="length">The length of the Field</param>
        /// <param name="enumValues"></param>
        public Field(string fieldName, int startPos, Dictionary<string, string> enumValues) {
            // TODO: can have IsEnum property that checks if _enumValues is null.
            // FUCk! each enum value has a different description.
        }

        #endregion

        // Note: not sure if I need any methods for this object, as it is really a data object.
        // TODO: might want a method to extract field values.
    }

    /// <summary>
    /// Exception to throw if there is a problem with the IDocDefinition.
    /// Ref: http://blog.gurock.com/articles/creating-custom-exceptions-in-dotnet/
    /// </summary>
    public class IDocDefinitionException : Exception
    {
        #region private fields
        DebugLog _log = DebugLog.Instance;
        #endregion

        #region constructors
        /// <summary>
        /// 
        /// </summary>
        /// <param name="message"></param>
        public IDocDefinitionException(string message)
            : base(message)
        {
            _log.Write(message);
        }

        /// <summary>
        /// 
        /// </summary>
        /// <param name="message"></param>
        /// <param name="innerException"></param>
        public IDocDefinitionException(string message, Exception innerException)
            : base(message, innerException)
        {
            _log.Write(message);
        }
        #endregion
    }

    /// <summary>
    /// The IDoc class contains the Segment/Field values. It can output as XML or as a flat-text IDoc file.
    /// 
    /// To learn more about IDocs, it is suggested that you read:
    /// * http://www.saptraininghub.com/all-about-idocdefinition-architecture-implementation/
    /// As of Release 4.6, the IDoc interface supports XML for outbound and inbound processing.
    /// </summary>
    public class IDoc
    {
        #region private fields
        DebugLog _log = DebugLog.Instance;
        #endregion

        #region properties
        /// <summary>
        /// The IDoc Basic Type (from IDOCTYP field in Control Record)
        /// </summary>
        public string Type {
            get;
            private set;
        }

        /// <summary>
        /// The IDoc number (from DOCNUM field in Control Record)
        /// </summary>
        public string Number {
            get;
            private set;
        }

        /// <summary>
        /// IDoc Control Record for Interface to External System
        /// The IDoc Control Record is always the first line in the IDoc file.
        /// </summary>
        public Dictionary<string, string> ControlRecord {
            get;
            private set;
        }

        /// <summary>
        /// The Segments of the IDoc.
        /// Note that the each Segment also contains the fields from the Data Record.
        /// </summary>
        public List<Dictionary<string, string>> Segments {
            get;
            private set;
        }

        /// <summary>
        /// IDoc Data Record for Interface to External System
        /// The IDoc Data Record specifies common fields at the beginning of each line in the IDoc file, and the SDATA area that 
        /// contains all the Segment data fields.
        /// </summary>
        //public Dictionary<string, string> DataRecord {
        //    get;
        //    private set;
        //}

        /// <summary>
        /// IDoc Status Record for Interface to External System
        /// Note: I am pretty sure that I will never see an IDoc Status Record, because I think they are removed before 
        /// they are stored on the filesystem.
        /// </summary>
        //public Dictionary<string, string> StatusRecord {
        //    get;
        //    private set;
        //}

        /// <summary>
        /// The IDocDefinition contains information about segment properties and field positions. It is needed in order
        /// to interpret the flat-text IDoc file.
        /// </summary>
        public IDocDefinition Definition {
            get;
            private set;
        }

        /// <summary>
        /// The XSD (exported from WE60) contains enough information to validate the field lengths and values in an 
        /// IDoc if it is in XML format.
        /// Note: This property must be set before checking the .IsValid property.
        /// </summary>
        public XElement Xsd { // TODO: it would be better to have a LoadXsd() method, as the XSD must be modified before being used for validation.
            get;
            private set;
        }
        #endregion

        #region constructors
        /// <summary>
        /// The no-args constructor is not allowed. You must create an instance of the IDoc class with an IDocDefinition and an IDoc file.
        /// </summary>
        private IDoc() { }

        /// <summary>
        /// When an IDoc object is created, the fields are read according to positions from the IDocDefinition. 
        /// An IDocException is thrown if the 
        /// </summary>
        /// <param name="definition">The IDocDefinition</param>
        /// <param name="idoc">The contents of a flat-text IDoc file</param>
        public IDoc(IDocDefinition definition, string idoc) {
            _log.Write("========== New IDoc created ==========");
            Definition = definition;
            ControlRecord = new Dictionary<string, string>();
            Segments = new List<Dictionary<string, string>>();
            ParseIDoc(idoc); // all the hard work is done by this method.
        }
        #endregion

        #region public methods
        /// <summary>
        /// An XML representation of the IDoc.
        /// Note that it would be possible to do Schema validation of this XML with no changes to the XSD, but this
        /// feature has been deferred.
        /// </summary>
        /// <returns></returns>
        public XElement Xml() {
            _log.Write("Building XML output...");

            XElement idoc = new XElement("IDOC", new XAttribute("BEGIN", "1"));
            // Add the Control Record fields
            XElement seg = new XElement(ControlRecord["TABNAM"], new XAttribute("SEGMENT", "1"));
            foreach (KeyValuePair<string, string> field in ControlRecord) {
                seg.Add(new XElement(field.Key, field.Value));
            }
            idoc.Add(seg);

            // Add each segment (in order)
            foreach(Dictionary<string, string> segment in Segments) {
                seg = new XElement(segment["SEGNAM"], new XAttribute("SEGMENT", "1"));
                foreach(KeyValuePair<string, string> field in segment) {
                    seg.Add(new XElement(field.Key, field.Value));
                }
                idoc.Add(seg);
            }
            XElement xml = new XElement(Type, idoc);

            _log.Write("XML IDoc:\n{0}", xml.ToString());
            return xml;
        }

        /// <summary>
        /// Returns true if the IDoc segments and fields are valid according to the XSD. This includes field lengths, 
        /// enumerated values, 
        /// Note: Getting this property will cause an exception to be throw if it is called before the Xsd property 
        /// has been set.
        /// Note: This is quite an expensive property to call, as it will need to generate an XML representation of 
        /// the IDoc before checking it with the XSD.
        /// 
        /// NOTES:
        /// From OxygenXml...
        /// Warning (http://www.w3.org/TR/xml-schema-1, oxygen-maxOccursLimit) oxygen-maxOccursLimit: In the declaration of 'element', the value of 'maxOccurs' is '999999', it will be considered 'unbounded' for validation because large values for maxOccurs are not supported by Xerces.
        /// Warning (http://www.w3.org/TR/xml-schema-1, oxygen-maxOccursLimit) oxygen-maxOccursLimit: In the declaration of 'element', the value of 'maxOccurs' is '999999', it will be considered 'unbounded' for validation because large values for maxOccurs are not supported by Xerces.
        /// Warning (http://www.w3.org/TR/xml-schema-1, oxygen-maxOccursLimit) oxygen-maxOccursLimit: In the declaration of 'element', the value of 'maxOccurs' is '999999', it will be considered 'unbounded' for validation because large values for maxOccurs are not supported by Xerces
        /// 
        /// Note: may have to manually add the fields from the Data Record to each Segment definition in the XSD, so that it can properly validate (and so the IDoc is easier to generate).
        /// </summary>
        /// <returns></returns>
        public bool IsValid() {
            throw new NotImplementedException("This will be implemented in a future version of the IDoc Generator.");
        }

        /// <summary>
        /// 
        /// It does the following
        ///  - adds quotes around lines (preserving indenting)
        ///  - escapes quote for attributes
        ///  - adds a length attribute for each field
        ///  - adds a comment with the Segment/Field description
        ///  - adds a comment for enumarated fields with allowed values (and their descriptions)
        /// 
        /// Example output:
        /// "<ZISUPODMAS_BAPIZBUSMASSENDEM01>"
        /// "    <IDOC BEGIN=\"1\">"
        /// "        <EDI_DC40 SEGMENT=\"1\">"                    // IDoc Control Record for Interface to External System
        /// "            <TABNAM length=\"10\">EDI_DC40</TABNAM>" // Name of Table Structure
        /// "            <MANDT length=\"3\">MAN</MANDT>"         // Client
        /// "            <DIRECT length=\"1\">1</DIRECT>"         // Direction [1 = Outbound, 2 = Inbound]
        /// 
        /// </summary>
        /// <returns>Text that is ready to be used by a function in VuGen.</returns>
        public string VuGenXml() {
            _log.Write("Building VuGen output...");

            // Start building the IDoc string
            string idoc = String.Format(
                "    // Create an IDoc file from XML input. Note that values can be parameterised.\n" +
                "    idoc_create(\"IDocParam\",\n" +
                "        \"<{0}>\"\n" +
                "        \"    <IDOC BEGIN=\\\"1\\\">\"\n", Type);

            // Add the IDoc Control Record fields
            string segmentName = ControlRecord["TABNAM"];
            string segmentDescription = Definition.ControlRecord.Description;
            idoc += String.Format(
                "        \"        <{0} SEGMENT=\\\"1\\\">\" // {1}\n", segmentName, segmentDescription);
            foreach (KeyValuePair<string, string> field in ControlRecord) {
                string fieldDescription = Definition.ControlRecord[field.Key].Description;
                int fieldLength = Definition.ControlRecord[field.Key].Length;
                idoc += String.Format(
                    "        \"            <{0} length=\\\"{1}\\\">{2}</{3}>\" // {4}\n", field.Key, fieldLength.ToString(), field.Value, field.Key, fieldDescription);
            }
            idoc += String.Format(
                "        \"        </{0}>\"\n", segmentName);

            // Add each IDoc segment (in order)
            foreach (Dictionary<string, string> segment in Segments) {
                segmentName = segment["SEGNAM"];
                segmentDescription = Definition.Segments[segmentName].Description;
                idoc += String.Format(
                    "        \"        <{0} SEGMENT=\\\"1\\\">\" // {1}\n", segmentName, segmentDescription);
                foreach (KeyValuePair<string, string> field in segment) {
                    // The field Desciption could be in either the Data Segment definition or the Segment definition.
                    // Note that this code assumes that field names are never the same in the Data Record and the Segment Data.
                    string fieldDescription;
                    int fieldLength;
                    if (Definition.DataRecord.Contains(field.Key)) {
                        fieldDescription = Definition.DataRecord[field.Key].Description;
                        fieldLength = Definition.DataRecord[field.Key].Length;
                    } else {
                        fieldDescription = Definition.Segments[segmentName][field.Key].Description;
                        fieldLength = Definition.Segments[segmentName][field.Key].Length;
                    }
                    idoc += String.Format(
                    "        \"            <{0} length=\\\"{1}\\\">{2}</{3}>\" // {4}\n", field.Key, fieldLength.ToString(), field.Value, field.Key, fieldDescription);
                }
                idoc += String.Format(
                "        \"        </{0}>\"\n", segmentName);
            }

            // Add the last part of the IDoc string
            idoc += String.Format(
                "        \"    </IDOC>\"\n" +
                "        \"</{0}>\");\n", Type);

            // TODO: The license should be added from a file or from a registry key, so that it is not hard-coded for all users.
            string license = 
                "    // The license key must be set before idoc_create() can be called.\n" +
                "    idoc_set_license(\n" +
                "        \"<license>\"\n" +
                "        \"    <name>Joe User</name>\"\n" +
                "        \"    <company>BigCo</company>\"\n" +
                "        \"    <email>joe.user@example.com</email>\"\n" +
                "        \"    <key>ANUAA-ADHHB-BS7VU-MVH45-9ZG3B-U3PUQ</key>\"\n" +
                "        \"    <expires>2013-10-01</expires>\"\n" +
                "        \"</license>\");\n";

            // TODO: put error message code here in case DLL is not found.
            string dll = 
                "    // The IDoc DLL must be loaded before any idoc_ functions are called.\n" +
                "    int rc = lr_load_dll(\"idoc.dll\");\n" +
                "    if (rc != 0) {\n" +
                "        lr_error_message(\"Problem loading idoc.dll\");\n" +
                "        lr_abort();\n" +
                "    }\n";

            // This is the Action.c file
            // Note special escaping for curly braces due to String.Format replacement parameters.
            string action = String.Format(
                "Action()\n" +
                "{{\n" +
                "{0}" +
                "\n" +
                "{1}" +
                "\n" +
                "{2}" +
                "\n" +
                "    return 0;\n" +
                "}}", dll, license, idoc);

            _log.Write("VuGen output:\n{0}", action);
            return action;
        }
        #endregion

        #region private methods

        /// <summary>
        /// Extracts field data from each Segment in the input IDoc.
        /// </summary>
        /// <param name="idoc">The flat-text IDoc file</param>
        /// <returns>Nothing, or throws an exception if there is a problem parsing the IDoc.</returns>
        private void ParseIDoc(string idoc) {
            _log.Write("Parsing flat text input IDoc:\n{0}", idoc);

            // Each Record/Segment will be on a new line.
            // "RemoveEmptyEntries" handles case of blank rows due to "\r\n"
            string[] rows = idoc.Split(new char[] { '\r', '\n' }, StringSplitOptions.RemoveEmptyEntries);
            if (rows.Length < 2) {
                throw new IDocDefinitionException("An IDoc cannot have less than 2 segments.");
            }

            // The first row is always the Control Record. All other rows are Segments, with a Data Record at the start.
            _log.Write("Starting Control Record...");
            foreach(Field field in Definition.ControlRecord) {
                string val = rows[0].Substring(field.Position, field.Length).TrimEnd();
                _log.Write("{0}={1}", field.Name, val);
                ControlRecord.Add(field.Name, val);
                if (field.Name == "IDOCTYP") {
                    Type = val;
                } else if (field.Name == "DOCNUM") {
                    Number = val;
                }
            }

            // Process all the Segments
            for (int i = 1; i < rows.Length; i++) {
                // Process the fields from the Data Record (except the SDATA field)
                Dictionary<string, string> currentSegment = new Dictionary<string, string>();
                string segmentName = null;
                foreach (Field field in Definition.DataRecord) {
                    if (field.Name == "SDATA") {
                        break; // this is the last field in the Data Record section of the Segment.
                    }
                    string val = rows[i].Substring(field.Position, field.Length).TrimEnd(); // TODO: can throw an OutOfBounds Exception if it is the wrong IDoc.
                    if (field.Name == "SEGNAM") {
                        segmentName = val;
                        _log.Write("Starting Segment \"{0}\"...", segmentName);
                    }
                    _log.Write("{0}={1}", field.Name, val);
                    currentSegment.Add(field.Name, val);
                }
                // Process the fields from the specified Segment.
                foreach (Field field in Definition.Segments[segmentName]) { // TODO: can throw a KeyNotFoundException if it is the wrong IDoc.
                    string val = rows[i].Substring(field.Position, field.Length).TrimEnd();
                    _log.Write("{0}={1}", field.Name, val);
                    currentSegment.Add(field.Name, val);
                }
                Segments.Add(currentSegment);
            }
            return;
        }
        #endregion
    }

    /// <summary>
    /// NOTE: it is probably better to add the schema to the IDoc, and give it an IsValid() method.
    /// Having a separate class for the schema will not work because I am going to have to additional elements for the
    /// fields in the Data Record to each segment.
    /// </summary>
    public class IDocSchema
    {
        #region fields
        private DebugLog _log = DebugLog.Instance;
        private XmlSchemaSet schemas = new XmlSchemaSet();
        #endregion

        #region properties
        #endregion

        #region constructors
        /// <summary>
        /// The no-args constructor is not allowed.
        /// </summary>
        private IDocSchema() { }

        /// <summary>
        /// Constructor to create a new IDocSchema from an XSD that has been exported from SAP.
        /// </summary>
        /// <param name="xsd"></param>
        public IDocSchema(XElement xsd) {
            _log.Write("New IDocSchema created from:\n{0}", xsd.ToString());
            schemas.Add("", XmlReader.Create(new StringReader(xsd.ToString())));

        }
        #endregion

        #region public methods
        /// <summary>
        /// Create an IDoc Schema from an XSD file that has been exported from SAP.
        /// </summary>
        /// <param name="path">The XSD filename</param>
        /// <returns>Returns a new IDocSchema object.</returns>
        public static IDocSchema Load(string path) {
            DebugLog _log = DebugLog.Instance; // needed here as this is a static method.
            _log.Write("Calling IDocSchema.Load({0})", path);
            // Read file contents
            XElement definition;
            try {
                definition = XElement.Load(path);
            }
            catch (Exception e) {
                string msg = String.Format("Problem reading file {0}", path);
                throw new IDocDefinitionException(msg, e);
            }
            return new IDocSchema(definition);
        }

        /// <summary>
        /// Checks whether the IDoc XML conforms to the definition in the XSD.
        /// </summary>
        /// <param name="idoc">The IDoc to check.</param>
        /// <returns>Returns true if the IDoc validates successfully, otherwise throws an IDocDefinitionException (yes,
        /// this is a bit of a WTF).</returns>
        public bool Validate(XElement idoc) {
            // Schema validation is much simpler if you use an XDocument instead of an XElement.
            XDocument doc = new XDocument(idoc);

            // Note that the second argument is a ValidationEventHandler(Object sender, ValidationEventArgs e)
            doc.Validate(schemas, (o, e) => {
                string msg = String.Format("The IDoc XML did not validate.\n{0}", e.Message);
                throw new IDocDefinitionException(msg);
            });

            return true;
        }

        #endregion
        

    }
}

/* 
 * 
 * NOTES
 * -----
 * When to use properties instead of functions
 * http://stackoverflow.com/questions/1374273/when-to-use-properties-instead-of-functions
 * 
 * Create XML Data From an XSD Schema File 
 * http://xmlgrid.net/genXml.html <- gives error "invalid schema, cannot generate XML data from this schema source
 *
 * 
 * Note that this program will not handle IDoc files with multiple IDoc numbers in them.
 * 
 */