using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Xml;
using System.Xml.Linq;
using System.Xml.XPath;

//// Note that this program will not handle IDoc files with multiple IDoc numbers in them.

namespace MyLoadTest.SapIDocGenerator
{
    /// <summary>
    /// This class contains the definition of an IDoc (segments, fields, etc).
    /// The definition must be created from a file that has been exported from SAP.
    /// An IDoc is constructed of named segments (Dictionary?)
    /// A segment is constructed of fields that are position-based. Each field is a key, and each position has a start position and a length.
    ///
    /// Note: The SapIDocDefinition does not have a description, as these are not exported in the C Header or the IDoc Structure.
    ///
    /// For those of you who have noticed that WE60 doesn't show the detailed documentation in the MySAP environments
    /// and like me have been using the old 4.6c systems for reference, you can modify your personal settings to show
    /// the documentation by default; here's the note: "As of Release 6.10, in transactions WE60 and WE63,
    /// documentation is no longer generated by default for the segment fields when the documentation is generated. To
    /// activate the generation of the documentation from the corresponding data elements, proceed as follows:
    /// WE60/WE63. > Goto > User settings. Here you must set the indicator for 'Display of the documentation' under
    /// 'Display attributes for IDOC types' and then save the change. Now the documentation is also displayed for the
    /// segment fields when WE60/WE63 is executed.
    /// Source: http://www.erpgenie.com/sapedi/idoc_interface.htm
    ///
    /// Useful SAP transactions:
    /// WE60 is for Documentation for IDoc types
    /// WE30 is for Creating IDoc extension type
    ///
    /// </summary>
    public sealed class SapIDocDefinition
    {
        #region Constructors

        /// <summary>
        /// Constructor to create an SapIDocDefinition when the segment contents are already known
        /// Note: The c-Header and the exported Structure do not contain an IDoc description. The description is only
        /// found in the XSD (which does not contain enough information to create an SapIDocDefinition).
        /// </summary>
        /// <param name="name">Name of IDoc type</param>
        /// <param name="controlRecord">The Control Record Segment</param>
        /// <param name="dataRecord">The Data Record Segment</param>
        /// <param name="segments">The Segments of the IDoc</param>
        private SapIDocDefinition(
            string name,
            SapIDocSegment controlRecord,
            SapIDocSegment dataRecord,
            Dictionary<string, SapIDocSegment> segments)
        {
            DebugLog.Write("========== Creating {0} with dictionary of Segments ==========", GetType().Name);

            #region Argument Check

            if (string.IsNullOrEmpty(name))
            {
                throw new ArgumentException("IDoc name cannot be empty.", "name");
            }

            if (controlRecord == null)
            {
                throw new ArgumentNullException("controlRecord");
            }

            if (dataRecord == null)
            {
                throw new ArgumentNullException("dataRecord");
            }

            if (segments == null)
            {
                throw new ArgumentNullException("segments");
            }

            #endregion

            this.Name = name;
            this.ControlRecord = controlRecord;
            this.DataRecord = dataRecord;
            this.Segments = segments;
        }

        #endregion

        #region Public Properties

        /// <summary>
        ///     Gets or sets the IDoc name.
        /// </summary>
        /// <remarks>
        ///     For instance, &quot;ZISUPODMAS_BAPIZBUSMASSENDEM01&quot;.
        /// </remarks>
        public string Name
        {
            get;
            private set;
        }

        public SapIDocSegment ControlRecord
        {
            get;
            private set;
        }

        public SapIDocSegment DataRecord
        {
            get;
            private set;
        }

        /// <summary>
        /// Note: probably shouldn't use this
        /// </summary>
        public Dictionary<string, SapIDocSegment> Segments
        {
            get;
            private set;
        }

        ///// <summary>
        ///// The IDoc description e.g. "BAPI Outbound;Meter Asset Standing Data Updates".
        ///// Note that this property can only be set when an instance of the class is created.
        ///// Note that this property can be found in the XSD definition, but not in the C-Header definition or the
        ///// Structure definition.
        ///// </summary>
        ////public string Description
        ////{
        ////    get { return _idocDescription; }
        ////    private set
        ////    {
        ////        if (String.IsNullOrEmpty(value))
        ////        {
        ////            throw new SapIDocException("IDoc description cannot be empty."); // This might cause problems if they haven't bothered to enter a description.
        ////        }
        ////        _log.Write("IDoc description: {0}", value);
        ////        _idocDescription = value;
        ////    }
        ////}

        #endregion

        #region Public Methods

        /////// <summary>
        /////// Create an IDoc definition from an XSD file that has been exported from SAP.
        /////// </summary>
        /////// <param name="path">The XSD filename</param>
        /////// <returns>Returns a new IDocDefinion object.</returns>
        ////public static SapIDocDefinition LoadXsd(string path)
        ////{
        ////    // Read file contents
        ////    XElement definition;
        ////    try
        ////    {
        ////        definition = XElement.Load(path);
        ////    }
        ////    catch (Exception e)
        ////    {
        ////        string msg = String.Format("Problem reading file {0}", path);
        ////        throw new SapIDocException(msg, e);
        ////    }
        ////    return new SapIDocDefinition(definition);
        ////}

        /// <summary>
        /// Reads an IDoc Definition (C-Header) from the file system, and creates an SapIDocDefinition object.
        /// </summary>
        /// <param name="path">A file containing the IDoc Definition as a C Header.</param>
        /// <returns>A new SapIDocDefinition object</returns>
        public static SapIDocDefinition LoadHeader(string path)
        {
            DebugLog.Write("Calling {0} with file: {1}", MethodBase.GetCurrentMethod().GetQualifiedName(), path);

            SapIDocSegment controlRecord = null;
            SapIDocSegment dataRecord = null;
            var segments = new Dictionary<string, SapIDocSegment>();

            if (!File.Exists(path))
            {
                throw new SapIDocException(string.Format("Could not find C Header file: {0}", path));
            }

            DebugLog.Write("C Header file contents:{0}{1}", Environment.NewLine, File.ReadAllText(path));

            // Convert the C code to XML (srcml) so it can be easily processed.
            var srcml = ConvertCToSrcml(path);

            // The src2srcml command adds "src:" namespace prefixes to all elements.
            var nsm = new XmlNamespaceManager(new NameTable());
            nsm.AddNamespace("src", "http://www.sdml.info/srcML/src");
            //// Note that XPathSelectElement does not use the default namespace (""), will always return NULL if you query an XML document that has a default namespace.
            nsm.AddNamespace("cpp", "http://www.sdml.info/srcML/cpp");

            // Extract the field definitions from each IDoc segment (typedef/struct).
            var structsXml = srcml.XPathSelectElements("/src:typedef", nsm);
            foreach (var seg in structsXml)
            {
                var segmentName = seg.XPathSelectElement("./src:name", nsm).Value.ToUpper();
                var tmpSegDescComment = seg.XPathSelectElement("./src:type/src:struct/src:comment", nsm).Value;
                var segmentDescription = tmpSegDescComment.Substring(3, tmpSegDescComment.Length - (3 + 2)).TrimEnd();
                //// remove start/end block-comment, and any trailing whitespace.
                var currentSegment = new SapIDocSegment(segmentName, segmentDescription);
                //// must Add() each field to this separately.

                var fieldsXml =
                    seg.XPathSelectElements("./src:type/src:struct/src:block/src:decl_stmt", nsm).ToArray();
                var commentsXml =
                    seg.XPathSelectElements("./src:type/src:struct/src:block/src:comment", nsm).ToArray();
                if (fieldsXml.Count() != commentsXml.Count())
                {
                    throw new SapIDocException(
                        "Each field definition in the C-Header should have a matching comment.");
                }

                int fieldStartPos; // The starting position changes if it is a data segment.
                switch (segmentDescription)
                {
                    case "IDoc Control Record for Interface to External System":
                        fieldStartPos = 0;
                        controlRecord = currentSegment;
                        break;

                    case "IDoc Data Record for Interface to External System":
                        fieldStartPos = 0;
                        dataRecord = currentSegment;
                        break;

                    case "IDoc Status Record for Interface to External System":
                        DebugLog.Write("Skipping Status Record definition, as this is not needed to read an IDoc.");
                        continue;
                    default:
                        fieldStartPos = dataRecord.EnsureNotNull()["SDATA"].StartPosition;
                        segments.Add(segmentName, currentSegment);
                        break;
                }

                foreach (var fld in fieldsXml.Zip(commentsXml, (field, comment) => new { field, comment }))
                {
                    var fieldName =
                        fld.field.XPathSelectElement("./src:decl/src:name/src:name", nsm).Value.ToUpperInvariant();
                    var fieldLength = Convert.ToInt32(
                        fld.field.XPathSelectElement("./src:decl/src:name/src:index/src:expr", nsm).Value);
                    var tmpFldDescComment = fld.comment.Value;
                    var fieldDescription = tmpFldDescComment
                        .Substring(3, tmpFldDescComment.Length - (3 + 2))
                        .TrimEnd();
                    //// remove start/end block-comment, and any trailing whitespace.
                    currentSegment.Add(new SapIDocField(fieldName, fieldDescription, fieldStartPos, fieldLength));
                    fieldStartPos += fieldLength;
                }
            }

            //// To get the IDoc name, look for the comment that says "/* Segment structures for IDoc type ZISUPODMAS_BAPIZBUSMASSENDEM01 */".
            //// Note that there is no IDoc description in the C-Header or the exported Structure.
            var tmpIdocName = srcml
                .XPathSelectElement("//src:comment[contains(., 'Segment structures for IDoc type')]", nsm)
                .Value;
            var idocName = tmpIdocName.Substring(36, tmpIdocName.Length - (36 + 2)).TrimEnd();
            //// remove start/end block-comment, and any trailing whitespace.

            return new SapIDocDefinition(idocName, controlRecord, dataRecord, segments);
        }

        /////// <summary>
        ///////
        /////// The IDoc definition looks like this:
        /////// BEGIN_RECORD_SECTION
        ///////   BEGIN_CONTROL_RECORD
        ///////     BEGIN_FIELDS
        ///////       NAME                TABNAM
        ///////       TEXT                Name of Table Structure
        ///////       TYPE                CHARACTER
        ///////       LENGTH              000010
        ///////       FIELD_POS           0001
        ///////       CHARACTER_FIRST     000001
        ///////       CHARACTER_LAST      000010
        ///////
        /////// The structure of the IDoc definition is:
        ///////     BEGIN_RECORD_SECTION
        ///////         BEGIN_CONTROL_RECORD
        ///////             BEGIN_FIELDS (multiple fields)
        ///////             END_FIELDS
        ///////         END_CONTROL_RECORD
        ///////         BEGIN_DATA_RECORD
        ///////             BEGIN_FIELDS (multiple fields)
        ///////             END_FIELDS
        ///////         END_DATA_RECORD
        ///////         BEGIN_STATUS_RECORD
        ///////             BEGIN_FIELDS (multiple fields)
        ///////             END_FIELDS
        ///////         END_STATUS_RECORD
        ///////     END_RECORD_SECTION
        ///////     BEGIN_SEGMENT_SECTION
        ///////         BEGIN_IDOC
        ///////             BEGIN_SEGMENT (multiple segments)
        ///////                 BEGIN_FIELDS (multiple fields)
        ///////                 END_FIELDS
        ///////             END_SEGMENT
        ///////         END_IDOC
        ///////     END_SEGMENT_SECTION
        /////// </summary>
        /////// <param name="text">A String that contains TODO.</param>
        /////// <returns></returns>
        ////public static SapIDocDefinition ParseStructure(string text)
        ////{
        ////_log.Write("Parsing IDoc definition.");
        ////// Note: will replace this with a state table in the future.
        ////Dictionary<string, bool> state = new Dictionary<string, bool>() {
        ////    {"RECORD_SECTION", false},
        ////    {"CONTROL_RECORD", false},
        ////    {"DATA_RECORD", false},
        ////    {"STATUS_RECORD", false},
        ////    {"SEGMENT_SECTION", false},
        ////    {"IDOC", false},
        ////    {"SEGMENT", false},
        ////    {"FIELDS", false}
        ////};
        ////// break string into lines, and extract name and value using a regular expression.
        ////using (StringReader sr = new StringReader(text))
        ////{
        ////    // Regular expression should match:
        ////    // - the start of a line, then
        ////    // - zero or more whitespace characters, then
        ////    // - 1 or more alpha characters (the first word => name), then
        ////    // - zero or more whitespace characters, then
        ////    // - zero or more alpha characters or whitespace characters (multiple words => value), then
        ////    // - the end of a line.
        ////    // Note use of named groups
        ////    // Useful C# regex tutorial here: http://www.codeproject.com/Articles/9099/The-30-Minute-Regex-Tutorial
        ////    //Regex regex = new Regex(@"^\s*(?<name>\w+).*"); // works for first word
        ////    //Regex regex = new Regex(@"^\s*\b(?<name>\w+)\b"); // works for first word
        ////    Regex regex = new Regex(@"^\s*\b(?<name>\w+)\b\s*(?<value>[\w\s]*)$");
        ////    Match match;
        ////    string line;
        ////    int lineNum = 0;
        ////    while ((line = sr.ReadLine()) != null)
        ////    {
        ////        lineNum++;
        ////        match = regex.Match(line);
        ////        string name = match.Groups["name"].Value;
        ////        string value = match.Groups["value"].Value;
        ////        // TODO: Replace this with a proper state machine/state table. This is kludgy.
        ////        switch (name)
        ////        {
        ////            case "":
        ////                // Ignore blank lines
        ////                break;
        ////            case "BEGIN_RECORD_SECTION":
        ////                if ((state["RECORD_SECTION"] == false) &&
        ////                    (state["CONTROL_RECORD"] == false) &&
        ////                    (state["DATA_RECORD"] == false) &&
        ////                    (state["STATUS_RECORD"] == false) &&
        ////                    (state["SEGMENT_SECTION"] == false) &&
        ////                    (state["IDOC"] == false) &&
        ////                    (state["SEGMENT"] == false) &&
        ////                    (state["FIELDS"] == false))
        ////                {
        ////                    state["RECORD_SECTION"] = true;
        ////                }
        ////                else
        ////                {
        ////                    goto default;
        ////                }
        ////                break;
        ////            case "END_RECORD_SECTION":
        ////                if ((state["RECORD_SECTION"] == true) &&
        ////                    (state["CONTROL_RECORD"] == false) &&
        ////                    (state["DATA_RECORD"] == false) &&
        ////                    (state["STATUS_RECORD"] == false) &&
        ////                    (state["SEGMENT_SECTION"] == false) &&
        ////                    (state["IDOC"] == false) &&
        ////                    (state["SEGMENT"] == false) &&
        ////                    (state["FIELDS"] == false))
        ////                {
        ////                    state["RECORD_SECTION"] = false;
        ////                }
        ////                else
        ////                {
        ////                    goto default;
        ////                }
        ////                break;
        ////            case "BEGIN_CONTROL_RECORD":
        ////                if ((state["RECORD_SECTION"] == true) &&
        ////                    (state["CONTROL_RECORD"] == false) &&
        ////                    (state["DATA_RECORD"] == false) &&
        ////                    (state["STATUS_RECORD"] == false) &&
        ////                    (state["SEGMENT_SECTION"] == false) &&
        ////                    (state["IDOC"] == false) &&
        ////                    (state["SEGMENT"] == false) &&
        ////                    (state["FIELDS"] == false))
        ////                {
        ////                    state["CONTROL_RECORD"] = true;
        ////                }
        ////                else
        ////                {
        ////                    goto default;
        ////                }
        ////                break;
        ////            case "END_CONTROL_RECORD":
        ////                if ((state["RECORD_SECTION"] == true) &&
        ////                    (state["CONTROL_RECORD"] == true) &&
        ////                    (state["DATA_RECORD"] == false) &&
        ////                    (state["STATUS_RECORD"] == false) &&
        ////                    (state["SEGMENT_SECTION"] == false) &&
        ////                    (state["IDOC"] == false) &&
        ////                    (state["SEGMENT"] == false) &&
        ////                    (state["FIELDS"] == false))
        ////                {
        ////                    state["CONTROL_RECORD"] = false;
        ////                }
        ////                else
        ////                {
        ////                    goto default;
        ////                }
        ////                break;
        ////            case "TODO":
        ////                if ((state["RECORD_SECTION"] == false) &&
        ////                    (state["CONTROL_RECORD"] == false) &&
        ////                    (state["DATA_RECORD"] == false) &&
        ////                    (state["STATUS_RECORD"] == false) &&
        ////                    (state["SEGMENT_SECTION"] == false) &&
        ////                    (state["IDOC"] == false) &&
        ////                    (state["SEGMENT"] == false) &&
        ////                    (state["FIELDS"] == false))
        ////                {
        ////                    state["TODO"] = true;
        ////                }
        ////                else
        ////                {
        ////                    goto default;
        ////                }
        ////                break;
        ////            case "TODO":
        ////                if ((state["RECORD_SECTION"] == false) &&
        ////                    (state["CONTROL_RECORD"] == false) &&
        ////                    (state["DATA_RECORD"] == false) &&
        ////                    (state["STATUS_RECORD"] == false) &&
        ////                    (state["SEGMENT_SECTION"] == false) &&
        ////                    (state["IDOC"] == false) &&
        ////                    (state["SEGMENT"] == false) &&
        ////                    (state["FIELDS"] == false))
        ////                {
        ////                    state["TODO"] = true;
        ////                }
        ////                else
        ////                {
        ////                    goto default;
        ////                }
        ////                break;
        ////            case "TODO":
        ////                if ((state["RECORD_SECTION"] == false) &&
        ////                    (state["CONTROL_RECORD"] == false) &&
        ////                    (state["DATA_RECORD"] == false) &&
        ////                    (state["STATUS_RECORD"] == false) &&
        ////                    (state["SEGMENT_SECTION"] == false) &&
        ////                    (state["IDOC"] == false) &&
        ////                    (state["SEGMENT"] == false) &&
        ////                    (state["FIELDS"] == false))
        ////                {
        ////                    state["TODO"] = true;
        ////                }
        ////                else
        ////                {
        ////                    goto default;
        ////                }
        ////                break;
        ////            case "TODO":
        ////                if ((state["RECORD_SECTION"] == false) &&
        ////                    (state["CONTROL_RECORD"] == false) &&
        ////                    (state["DATA_RECORD"] == false) &&
        ////                    (state["STATUS_RECORD"] == false) &&
        ////                    (state["SEGMENT_SECTION"] == false) &&
        ////                    (state["IDOC"] == false) &&
        ////                    (state["SEGMENT"] == false) &&
        ////                    (state["FIELDS"] == false))
        ////                {
        ////                    state["TODO"] = true;
        ////                }
        ////                else
        ////                {
        ////                    goto default;
        ////                }
        ////                break;
        ////            case "TODO":
        ////                if ((state["RECORD_SECTION"] == false) &&
        ////                    (state["CONTROL_RECORD"] == false) &&
        ////                    (state["DATA_RECORD"] == false) &&
        ////                    (state["STATUS_RECORD"] == false) &&
        ////                    (state["SEGMENT_SECTION"] == false) &&
        ////                    (state["IDOC"] == false) &&
        ////                    (state["SEGMENT"] == false) &&
        ////                    (state["FIELDS"] == false))
        ////                {
        ////                    state["TODO"] = true;
        ////                }
        ////                else
        ////                {
        ////                    goto default;
        ////                }
        ////                break;
        ////            case "TODO":
        ////                if ((state["RECORD_SECTION"] == false) &&
        ////                    (state["CONTROL_RECORD"] == false) &&
        ////                    (state["DATA_RECORD"] == false) &&
        ////                    (state["STATUS_RECORD"] == false) &&
        ////                    (state["SEGMENT_SECTION"] == false) &&
        ////                    (state["IDOC"] == false) &&
        ////                    (state["SEGMENT"] == false) &&
        ////                    (state["FIELDS"] == false))
        ////                {
        ////                    state["TODO"] = true;
        ////                }
        ////                else
        ////                {
        ////                    goto default;
        ////                }
        ////                break;
        ////            case "TODO":
        ////                if ((state["RECORD_SECTION"] == false) &&
        ////                    (state["CONTROL_RECORD"] == false) &&
        ////                    (state["DATA_RECORD"] == false) &&
        ////                    (state["STATUS_RECORD"] == false) &&
        ////                    (state["SEGMENT_SECTION"] == false) &&
        ////                    (state["IDOC"] == false) &&
        ////                    (state["SEGMENT"] == false) &&
        ////                    (state["FIELDS"] == false))
        ////                {
        ////                    state["TODO"] = true;
        ////                }
        ////                else
        ////                {
        ////                    goto default;
        ////                }
        ////                break;
        ////            case "TODO":
        ////                if ((state["RECORD_SECTION"] == false) &&
        ////                    (state["CONTROL_RECORD"] == false) &&
        ////                    (state["DATA_RECORD"] == false) &&
        ////                    (state["STATUS_RECORD"] == false) &&
        ////                    (state["SEGMENT_SECTION"] == false) &&
        ////                    (state["IDOC"] == false) &&
        ////                    (state["SEGMENT"] == false) &&
        ////                    (state["FIELDS"] == false))
        ////                {
        ////                    state["TODO"] = true;
        ////                }
        ////                else
        ////                {
        ////                    goto default;
        ////                }
        ////                break;
        ////            case "TODO":
        ////                if ((state["RECORD_SECTION"] == false) &&
        ////                    (state["CONTROL_RECORD"] == false) &&
        ////                    (state["DATA_RECORD"] == false) &&
        ////                    (state["STATUS_RECORD"] == false) &&
        ////                    (state["SEGMENT_SECTION"] == false) &&
        ////                    (state["IDOC"] == false) &&
        ////                    (state["SEGMENT"] == false) &&
        ////                    (state["FIELDS"] == false))
        ////                {
        ////                    state["TODO"] = true;
        ////                }
        ////                else
        ////                {
        ////                    goto default;
        ////                }
        ////                break;
        ////            case "TODO":
        ////                if ((state["RECORD_SECTION"] == false) &&
        ////                    (state["CONTROL_RECORD"] == false) &&
        ////                    (state["DATA_RECORD"] == false) &&
        ////                    (state["STATUS_RECORD"] == false) &&
        ////                    (state["SEGMENT_SECTION"] == false) &&
        ////                    (state["IDOC"] == false) &&
        ////                    (state["SEGMENT"] == false) &&
        ////                    (state["FIELDS"] == false))
        ////                {
        ////                    state["TODO"] = true;
        ////                }
        ////                else
        ////                {
        ////                    goto default;
        ////                }
        ////                break;
        ////            case "TODO":
        ////                if ((state["RECORD_SECTION"] == false) &&
        ////                    (state["CONTROL_RECORD"] == false) &&
        ////                    (state["DATA_RECORD"] == false) &&
        ////                    (state["STATUS_RECORD"] == false) &&
        ////                    (state["SEGMENT_SECTION"] == false) &&
        ////                    (state["IDOC"] == false) &&
        ////                    (state["SEGMENT"] == false) &&
        ////                    (state["FIELDS"] == false))
        ////                {
        ////                    state["TODO"] = true;
        ////                }
        ////                else
        ////                {
        ////                    goto default;
        ////                }
        ////                break;
        ////            case "TODO":
        ////                if ((state["RECORD_SECTION"] == false) &&
        ////                    (state["CONTROL_RECORD"] == false) &&
        ////                    (state["DATA_RECORD"] == false) &&
        ////                    (state["STATUS_RECORD"] == false) &&
        ////                    (state["SEGMENT_SECTION"] == false) &&
        ////                    (state["IDOC"] == false) &&
        ////                    (state["SEGMENT"] == false) &&
        ////                    (state["FIELDS"] == false))
        ////                {
        ////                    state["TODO"] = true;
        ////                }
        ////                else
        ////                {
        ////                    goto default;
        ////                }
        ////                break;
        ////            case "TODO":
        ////                if ((state["RECORD_SECTION"] == false) &&
        ////                    (state["CONTROL_RECORD"] == false) &&
        ////                    (state["DATA_RECORD"] == false) &&
        ////                    (state["STATUS_RECORD"] == false) &&
        ////                    (state["SEGMENT_SECTION"] == false) &&
        ////                    (state["IDOC"] == false) &&
        ////                    (state["SEGMENT"] == false) &&
        ////                    (state["FIELDS"] == false))
        ////                {
        ////                    state["TODO"] = true;
        ////                }
        ////                else
        ////                {
        ////                    goto default;
        ////                }
        ////                break;
        ////            case "NAME":
        ////                if ((state["FIELDS"] == true) && (name == null))
        ////                {
        ////                    name = value;
        ////                }
        ////                else
        ////                {
        ////                    goto default;
        ////                }
        ////                break;
        ////            case "TEXT":
        ////                if ((state["FIELDS"] == true) && (text == null))
        ////                {
        ////                    text = value;
        ////                }
        ////                else
        ////                {
        ////                    goto default;
        ////                }
        ////            case "TYPE":
        ////                if ((state["FIELDS"] == true) && (type == null))
        ////                {
        ////                    type = value;
        ////                }
        ////                else
        ////                {
        ////                    goto default;
        ////                }
        ////                break;
        ////            case "LENGTH":
        ////                if ((state["FIELDS"] == true) && (length == null))
        ////                {
        ////                    length = value;
        ////                }
        ////                else
        ////                {
        ////                    goto default;
        ////                }
        ////                break;
        ////            case "FIELD_POS":
        ////                if ((state["FIELDS"] == true) && (fieldPos == null))
        ////                {
        ////                    fieldPos = value;
        ////                }
        ////                else
        ////                {
        ////                    goto default;
        ////                }
        ////                break;
        ////            case "CHARACTER_FIRST":
        ////                if ((state["FIELDS"] == true) && (characterFirst == null))
        ////                {
        ////                    characterFirst = value;
        ////                }
        ////                else
        ////                {
        ////                    goto default;
        ////                }
        ////                break;
        ////            case "CHARACTER_LAST":
        ////                if (IsValidState(state) == true) { }
        ////                if ((state["FIELDS"] == true) && (characterLast == null))
        ////                {
        ////                    characterLast = value;
        ////                    // TODO: add field to segment.
        ////                    // Reset all field values
        ////                    name = null;
        ////                    text = null;
        ////                    type = null;
        ////                    length = null;
        ////                    fieldPos = null;
        ////                    characterFirst = null;
        ////                    characterLast = null;
        ////                }
        ////                else
        ////                {
        ////                    goto default;
        ////                }
        ////                break;
        ////            default:
        ////                string msg = String.Format("Invalid IDoc description element on line {0}.", lineNum);
        ////                _log.Write(msg);
        ////                throw new FormatException(msg);
        ////                break;
        ////        }
        ////        Console.WriteLine("Name: {0}", match.Groups["name"].Value);
        ////        Console.WriteLine("Value: {0}", match.Groups["value"].Value);
        ////        //Console.WriteLine(match.Groups["value"].Value);
        ////        // TODO: regex to break it into name/value pairs.
        ////        // TODO
        ////    }
        ////}
        ////Console.WriteLine();
        ////return new SapIDocDefinition();
        ////}

        ///// The structure of the IDoc definition is:
        /////     BEGIN_RECORD_SECTION
        /////         BEGIN_CONTROL_RECORD
        /////             BEGIN_FIELDS (multiple fields)
        /////             END_FIELDS
        /////         END_CONTROL_RECORD
        /////         BEGIN_DATA_RECORD
        /////             BEGIN_FIELDS (multiple fields)
        /////             END_FIELDS
        /////         END_DATA_RECORD
        /////         BEGIN_STATUS_RECORD
        /////             BEGIN_FIELDS (multiple fields)
        /////             END_FIELDS
        /////         END_STATUS_RECORD
        /////     END_RECORD_SECTION
        /////     BEGIN_SEGMENT_SECTION
        /////         BEGIN_IDOC
        /////             BEGIN_SEGMENT (multiple segments)
        /////                 BEGIN_FIELDS (multiple fields)
        /////                 END_FIELDS
        /////             END_SEGMENT
        /////         END_IDOC
        /////     END_SEGMENT_SECTION
        ////private static bool IsValidState(byte[] state)
        ////{
        ////    // http://stackoverflow.com/questions/713341/comparing-arrays-in-c-sharp
        ////    // var arraysAreEqual = Enumerable.SequenceEqual(a1, a2);
        ////    // validStates.SequenceEqual()
        ////    // A list of all valid states when reading an IDoc definition
        ////    List<bool[]> validStates = new List<bool[]>();
        ////    //                          RECORD_SECTION | CONTROL_RECORD | DATA_RECORD | STATUS_RECORD | SEGMENT_SECTION | IDOC | SEGMENT_SECTION | SEGMENT_VALUE | SEGMENT FIELDS | FIELD_VALUE
        ////    validStates.Add(new bool[] { true, false, false, false, false, false, false, false, false, false }); // BEGIN_RECORD_SECTION. At start of IDoc definition.
        ////    validStates.Add(new bool[] { false, false, false, false, false, false, false, false, false, false }); // BEGIN_CONTROL_RECORD.
        ////    validStates.Add(new bool[] { false, false, false, false, false, false, false, false, false, false }); // .
        ////    validStates.Add(new bool[] { false, false, false, false, false, false, false, false, false, false }); // END_RECORD_SECTION.
        ////    validStates.Add(new bool[] { false, false, false, false, false, false, false, false, false, false }); // END_RECORD_SECTION.
        ////    validStates.Add(new bool[] { false, false, false, false, false, false, false, false, false, false }); // END_RECORD_SECTION.
        ////    validStates.Add(new bool[] { false, false, false, false, false, false, false, false, false, false }); // END_RECORD_SECTION.
        ////    validStates.Add(new bool[] { false, false, false, false, false, false, false, false, false, false }); // BEGIN_FIELDS.
        ////    validStates.Add(new bool[] { false, false, false, false, false, false, false, false, false, false }); // END_RECORD_SECTION.
        ////    validStates.Add(new bool[] { false, false, false, false, false, false, false, false, false, false }); // END_RECORD_SECTION
        ////    return false;
        ////}

        #endregion

        #region Private Methods

        /// <summary>
        /// Converts C source code to srcml by calling src2srcml.exe
        ///
        /// Command line:
        /// src2srcml --language=C --xmlns:src=http://www.sdml.info/srcML/src idoc.xsd
        ///
        /// Note that src2srcml.exe always reads from the filesystem to avoid the hanging problem that occurs when
        /// piped input is longer than ~56 000 characters. The output is read from stdout (which has been redirected).
        /// It is not possible to suppress namespaces (using "--no-namespace-decl"), as this causes XElement.Load to
        /// throw an exception (cpp namespace not found). Do not use "-o", as we want output to be sent to stdout.
        /// </summary>
        /// <param name="path">The file name of the C Header</param>
        /// <returns>An XElement containing a srcml represenation of the C Header</returns>
        private static XElement ConvertCToSrcml(string path)
        {
            // Call the src2srcml.exe process, and pass the source code to it via stdin.
            var dllFolder = Path.GetDirectoryName(Assembly.GetExecutingAssembly().Location).EnsureNotNull();
            ////int tabSize = 4;
            var p = new Process
            {
                StartInfo =
                {
                    FileName = dllFolder + @"\src2srcml\src2srcml.exe",
                    //// assume it is always installed in the \srcml subdirectory.
                    Arguments = string.Format("--language=C --xmlns:src=http://www.sdml.info/srcML/src \"{0}\"", path),
                    CreateNoWindow = true, // prevent the new shell window from briefly flashing up
                    UseShellExecute = false,
                    //// needs to be false in order to redirect output. Must specify the full path name, as it will not use the shell's %PATH% variable.
                    RedirectStandardOutput = true,
                    RedirectStandardError = true,
                    RedirectStandardInput = true, // redirect all 3, as it should be all 3 or none
                    WorkingDirectory = dllFolder
                    //// If p.WorkingDirectory is not specified, the default working directory is %SYSTEMROOT%\system32
                }
            };

            DebugLog.Write("Calling \"{0}\" {1}", p.StartInfo.FileName, p.StartInfo.Arguments);
            p.Start();

            // Read output from stdout
            XElement srcml;
            try
            {
                var output = p.StandardOutput.ReadToEnd(); // .Dump()
                ////Console.WriteLine("########## OUTPUT ##########\n{0}\n########## END OUTPUT ##########", output);

                srcml = XElement.Parse(output);

                // ...then wait n milliseconds for exit (as after exit, it can't read the output)
                p.WaitForExit(10000); // Documentation: http://msdn.microsoft.com/en-us/library/ty0d8k56.aspx
            }
            catch (Exception ex)
            {
                var errorOutput = p.StandardError.ReadToEnd();
                var message = string.Format("Error when calling src2srcml:{0}{1}", Environment.NewLine, errorOutput);
                throw new SapIDocException(message, ex);
            }
            finally
            {
                p.Dispose(); // There is no real need to Close() if Dispose() is called.
            }

            return srcml;
        }

        #endregion
    }
}